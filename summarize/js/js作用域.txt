《--申明和定义、Hoisting(变量提升)--》
var a;
a = 1;

function foo() {
    if (!a) {
        a = 2;
    }
    alert(a);     // 此时的 a 并非函数体外的那个全局变量
}
//2

<ES5>
var a = 1;//实际上做了两步var = a;(声明)，a = 1;(定义)。且“声明”会被提升至最近的函数作用与或者顶层作用域。
//所以上面例子a在foo中已经被事先声明在头部，即 var a;所以此时a = undefined;所以!a为真。


<ES6>
let a = 1;//不存在上述情况哦！把 a = 2;换成 let a = 2;结果就是1了。



《--Scoping(作用域)--》
“为什么 a 不是声明在 if 语句中呢？（ES5环境）”
因为 JavaScript（ES5） 没有块级作用域（Block Scoping），只有函数作用域（Function Scoping）和顶层作用域，
所以说在JS中不是看见一对花括号 {} 就代表产生了新的作用域！
当然，变量声明的提升并非 Hoisting 的全部。在 JavaScript(ES5) 中，有四种方式可以让命名进入到作用域中（按优先级）：
1---语言定义的命名：比如 this 或者 arguments，它们在所有作用域内都有效且优先级最高，
    所以在任何地方你都不能把变量命名为 this 之类的，这样是没有意义的

2---形式参数：函数定义时声明的形式参数会作为变量被 hoisting 至该函数的作用域内。所以形式参数是本地的，
    不是外部的或者全局的。当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了

3---函数声明：函数体内部还可以声明函数，不过它们也都是本地的了

4---变量声明：这个优先级其实还是最低的，不过它们也都是最常用的


当这一点在ES6(let、const)中得到了改善。





《--函数声明与函数表达式的差别--》
function test() {
    foo();

    function foo() {
        alert("我是会出现的啦……");
    }
}

test();//"我是会出现的啦……"

function test() {
    foo();

    var foo = function() {
        alert("我不会出现的哦……");
    }
}

test();//foo is not function


在第一个例子里，函数 foo 是一个声明（!!!function也是一个声明!），既然是声明就会被提升（我特意包裹了一个外层作用域，
因为全局作用域需要你的想象，不是那么直观，但是道理是一样的），所以在执行 foo() 之前，作用域就知道函数 foo 的存在了。
这叫做函数声明（Function Declaration），函数声明会连通命名和函数体一起被提升至作用域顶部。

然而在第二个例子里，被提升的仅仅是变量名 foo，至于它的定义依然停留在原处。因此在执行 foo() 之前，作用域只知道 foo 的命名，
不知道它到底是什么，所以执行会报错（通常会是：undefined is not a function）。这叫做函数表达式（Function Expression），
函数表达式只有命名会被提升，定义的函数体则不会。

在<-函数作用域->或者<-顶层作用域->适合用这种<函数声明>的写法！




《--ES5与ES6关于块级作用域的函数声明--》
！ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，
在块级作用域之外不可引用。

！但浏览器却不会严格遵守这个规定。因为如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。
为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式，如下：
1--允许在块级作用域内声明函数。
2--函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
3--同时，函数声明还会提升到所在的块级作用域的头部。

所以浏览器的环境导致的行为差异太大，应该避免在块级作用域内使用函数声明。如果确实需要在块级作用域中声明函数，也应该写成函数表达式！！！

如果在<-块级作用域->中适合用<函数表达式>，毕竟有var、let、const这些猛将在，所以可控。









